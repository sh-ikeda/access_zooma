package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
)

func member(s string, a []string) bool {
	for _, q := range a {
		if s == q {
			return true
		}
	}
	return false
}

func main() {
	// Parse command line options
	a := flag.String("a", "", "comma-separated string of attributes to be collected")
	s := flag.Bool("s", false, "If true, a value of attributes not listed in `-a` option is separated with whitespace and each word is output as a query")
	flag.Parse()

	attr := strings.Split(*a, ",")
	toBeSeparated := *s

	bytes, err := ioutil.ReadFile(flag.Arg(0))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n %s [-a LIST] [-s] FILE", os.Args[0], os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	// Parse input json
	fmt.Fprintln(os.Stderr, "Parsing...")
	var decode_data interface{}
	if err := json.Unmarshal(bytes, &decode_data); err != nil {
		fmt.Fprintln(os.Stderr, err)
		if err, ok := err.(*json.SyntaxError); ok {
			fmt.Fprintln(os.Stderr, string(bytes[err.Offset-15:err.Offset+15]))
		}
		os.Exit(1)
	}
	fmt.Fprintf(os.Stderr, "Done. (Total %d entries)\n", len(decode_data.([]interface{})))

	// Collect designated attributes and output them
	fmt.Fprintln(os.Stderr, "Writing...")
	for _, data := range decode_data.([]interface{}) {
		d := data.(map[string]interface{})
		id := d["accession"].(string)
		ch := d["characteristics"].(map[string]interface{})
		n := 0
		for key, _ := range ch {
			if member(key, attr) {
				c := ch[key].([]interface{})
				x := c[0].(map[string]interface{})
				value := x["text"].(string)
				// in case that value has "\t"
				value = strings.Replace(value, "\t", " ", -1)
				fmt.Fprintf(os.Stdout, "%s\t%s\t%s\t\n", id, key, value)
				n++
			}
		}
		// When no attribute contains any keywords, output all
		if n == 0 {
			for key, _ := range ch {
				cell := ch[key].([]interface{})
				x := cell[0].(map[string]interface{})
				value := x["text"].(string)
				//slice := strings.Split(value, " ")
				slice := regexp.MustCompile("[ (),./]+").Split(value, -1)
				fmt.Fprintf(os.Stdout, "%s\t%s\t%s\t\n", id, key, value)
				if toBeSeparated && len(slice) > 1 {
					for _, word := range slice {
						if word != "" {
							fmt.Fprintf(os.Stdout, "%s\t%s\t%s\t%s\n", id, key, word, value)
						}
					}
				}
			}
		}
	}
	fmt.Fprintln(os.Stderr, "Done.")
}
